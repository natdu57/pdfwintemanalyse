<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur de Direction des Fl√®ches</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            border: 3px dashed #bdc3c7;
            border-radius: 15px;
            transition: all 0.3s ease;
            background: rgba(236, 240, 241, 0.5);
        }

        .upload-section:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .file-input {
            margin: 20px 0;
        }

        .file-input input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .canvas-container {
            position: relative;
            text-align: center;
            margin: 30px 0;
            border-radius: 15px;
            overflow: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            background: white;
            max-height: 600px;
            border: 2px solid #bdc3c7;
        }

        #imageCanvas {
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .zoom-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 2px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .zoom-level {
            font-size: 12px;
            color: #2c3e50;
            margin: 5px 0;
            font-weight: bold;
        }

        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .wind-calculator {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #2ecc71;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .wind-calculator:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .wind-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            align-items: end;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .input-group input, .input-group select {
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            background: white;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #2ecc71;
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.1);
        }

        .calculate-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(46, 204, 113, 0.3);
        }

        .wind-results {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .wind-result-card {
            background: rgba(46, 204, 113, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(46, 204, 113, 0.2);
        }

        .wind-result-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #27ae60;
            margin: 5px 0;
        }

        .wind-result-label {
            font-size: 0.9em;
            color: #2c3e50;
            font-weight: 500;
        }

        .wind-diagram {
            margin: 20px 0;
            text-align: center;
        }

        .wind-vector-display {
            width: 300px;
            height: 200px;
            margin: 0 auto;
            position: relative;
            background: rgba(236, 240, 241, 0.3);
            border: 2px solid #bdc3c7;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 768px) {
            .info-panel {
                grid-template-columns: 1fr;
            }
            
            .wind-inputs {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .wind-results {
                grid-template-columns: 1fr;
            }
        }

        .info-card {
            background: rgba(255, 255, 255, 0.8);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #667eea;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .info-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .info-card h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.3em;
        }

        .compass {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            position: relative;
            border: 3px solid #34495e;
            border-radius: 50%;
            background: radial-gradient(circle, #ecf0f1 0%, #bdc3c7 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .compass-arrow {
            width: 4px;
            height: 80px;
            background: linear-gradient(to top, #e74c3c 0%, #c0392b 100%);
            position: absolute;
            transform-origin: center bottom;
            border-radius: 2px;
            transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .compass-arrow::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 15px solid #e74c3c;
        }

        .compass-directions {
            position: absolute;
            width: 100%;
            height: 100%;
            font-weight: bold;
            color: #2c3e50;
            font-size: 18px;
        }

        .compass-directions span {
            position: absolute;
            font-weight: 800;
        }

        .north { top: 10px; left: 50%; transform: translateX(-50%); color: #e74c3c; }
        .south { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .east { right: 15px; top: 50%; transform: translateY(-50%); }
        .west { left: 15px; top: 50%; transform: translateY(-50%); }

        .coordinates {
            margin-top: 15px;
            padding: 15px;
            background: rgba(52, 73, 94, 0.1);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
        }

        .angle-display {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            margin: 20px 0;
            text-align: center;
        }

        .instructions {
            text-align: center;
            color: #7f8c8d;
            margin: 20px 0;
            font-style: italic;
            background: rgba(241, 196, 15, 0.1);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #f1c40f;
        }

        @media (max-width: 768px) {
            .info-panel {
                grid-template-columns: 1fr;
            }
            
            .compass {
                width: 150px;
                height: 150px;
            }
            
            .compass-arrow {
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß≠ Analyseur de Direction des Fl√®ches</h1>
        <p class="subtitle">S√©lectionnez une fl√®che sur votre document pour conna√Ætre sa direction par rapport au nord</p>
        
        <div class="upload-section">
            <h3>üìé Chargez votre document</h3>
            <div class="file-input">
                <label for="fileInput" class="file-label">
                    Choisir un fichier (PDF/Image)
                </label>
                <input type="file" id="fileInput" accept=".pdf,.jpg,.jpeg,.png,.gif,.bmp">
            </div>
            <p>Formats support√©s: PDF, JPG, PNG, GIF, BMP</p>
        </div>

        <div class="canvas-container" id="canvasContainer" style="display: none;">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">-</button>
                <button class="zoom-btn" onclick="resetZoom()">100%</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
            </div>
            <canvas id="imageCanvas"></canvas>
        </div>

        <div class="instructions" id="instructions" style="display: none;">
            üìã <strong>Instructions:</strong> Cliquez sur deux points pour d√©finir une fl√®che - d'abord la base, puis la pointe de la fl√®che
        </div>

        <div class="info-panel" id="infoPanel" style="display: none;">
            <div class="wind-calculator">
                <h3>üå™Ô∏è Calculateur de Vent pour Pilotes</h3>
                <p style="color: #7f8c8d; margin-bottom: 20px;">
                    Calculez automatiquement le vent de travers et le vent de face/arri√®re pour votre approche
                </p>
                
                <div class="wind-inputs">
                    <div class="input-group">
                        <label for="windSpeed">Force du vent (kt)</label>
                        <input type="number" id="windSpeed" placeholder="Ex: 15" min="0" max="100">
                    </div>
                    
                    <div class="input-group">
                        <label for="routeMagnetique">Route magn√©tique (¬∞)</label>
                        <input type="number" id="routeMagnetique" placeholder="Ex: 090" min="0" max="360">
                    </div>
                    
                    <div class="input-group">
                        <label for="capPiste">Cap de piste (¬∞)</label>
                        <input type="number" id="capPiste" placeholder="Ex: 095" min="0" max="360">
                    </div>
                    
                    <div class="input-group" style="grid-column: 1 / -1; text-align: center; margin-top: 10px;">
                        <button class="calculate-btn" onclick="calculateWindComponents()">
                            Calculer les composantes
                        </button>
                    </div>
                </div>
                
                <div class="wind-info" style="background: rgba(52, 152, 219, 0.1); padding: 15px; border-radius: 10px; margin: 15px 0; border-left: 4px solid #3498db;">
                    <p style="margin: 0; color: #2c3e50; font-size: 0.9em;">
                        <strong>üí° Info :</strong> La direction du vent est automatiquement prise depuis la fl√®che mesur√©e sur votre document.
                        <br><strong>Direction du vent mesur√©e :</strong> <span id="measuredWindDirection">-- ¬∞</span>
                    </p>
                </div>
                
                <div class="wind-results" id="windResults" style="display: none;">
                    <div class="wind-result-card">
                        <div class="wind-result-value" id="headwindValue">-- kt</div>
                        <div class="wind-result-label" id="headwindLabel">Vent de face</div>
                    </div>
                    <div class="wind-result-card">
                        <div class="wind-result-value" id="crosswindValue">-- kt</div>
                        <div class="wind-result-label">Vent de travers</div>
                    </div>
                    <div class="wind-result-card">
                        <div class="wind-result-value" id="windStrength">-- kt</div>
                        <div class="wind-result-label">Force du vent</div>
                    </div>
                </div>
                
                <div class="wind-diagram" id="windDiagram" style="display: none;">
                    <canvas id="windCanvas" width="300" height="200" class="wind-vector-display"></canvas>
                    <p style="font-size: 0.8em; color: #7f8c8d; margin-top: 10px;">
                        üîµ Vent total | üî¥ Vent de face/arri√®re | üü¢ Vent de travers
                    </p>
                </div>
            </div>

            <div class="info-card">
                <h3>üß≠ Boussole</h3>
                <div class="compass">
                    <div class="compass-directions">
                        <span class="north">N</span>
                        <span class="east">E</span>
                        <span class="south">S</span>
                        <span class="west">O</span>
                    </div>
                    <div class="compass-arrow" id="compassArrow"></div>
                </div>
                <div class="angle-display" id="angleDisplay">--¬∞</div>
            </div>
            
            <div class="info-card">
                <h3>üìä Informations de Direction</h3>
                <div id="directionInfo">
                    <div class="coordinates">
                        <strong>Point de d√©part:</strong> <span id="startPoint">Non d√©fini</span><br>
                        <strong>Point d'arriv√©e:</strong> <span id="endPoint">Non d√©fini</span><br>
                        <strong>Angle par rapport au Nord:</strong> <span id="angleText">--¬∞</span><br>
                        <strong>Direction cardinale:</strong> <span id="cardinalDirection">--</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script>
        let canvas, ctx;
        let startPoint = null;
        let endPoint = null;
        let imageLoaded = false;
        let originalImageData = null;
        let canvasScale = 1;
        let originalWidth = 0;
        let originalHeight = 0;
        let zoomLevel = 1;
        let baseWidth = 0;
        let baseHeight = 0;

        // Configuration PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileType = file.type;
            
            if (fileType === 'application/pdf') {
                loadPDF(file);
            } else if (fileType.startsWith('image/')) {
                loadImage(file);
            } else {
                alert('Format de fichier non support√©. Utilisez PDF ou une image.');
            }
        }

        function loadPDF(file) {
            const fileReader = new FileReader();
            fileReader.onload = function() {
                const typedarray = new Uint8Array(this.result);
                
                pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
                    // Charger la premi√®re page
                    pdf.getPage(1).then(function(page) {
                        const scale = 2; // Augmenter la r√©solution pour un meilleur zoom
                        const viewport = page.getViewport({ scale: scale });
                        
                        // Cr√©er un canvas temporaire pour le rendu PDF
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = viewport.width;
                        tempCanvas.height = viewport.height;
                        
                        setupCanvas(viewport.width, viewport.height);
                        
                        const renderContext = {
                            canvasContext: tempCtx,
                            viewport: viewport
                        };
                        
                        page.render(renderContext).promise.then(() => {
                            // Sauvegarder l'image originale haute r√©solution
                            originalImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                            imageLoaded = true;
                            updateCanvasSize();
                            showInterface();
                        });
                    });
                });
            };
            fileReader.readAsArrayBuffer(file);
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Cr√©er un canvas temporaire pour l'image
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    tempCtx.drawImage(img, 0, 0);
                    
                    setupCanvas(img.width, img.height);
                    
                    // Sauvegarder l'image originale
                    originalImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    imageLoaded = true;
                    updateCanvasSize();
                    showInterface();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(width, height) {
            canvas = document.getElementById('imageCanvas');
            ctx = canvas.getContext('2d');
            
            // Stocker les dimensions de base
            originalWidth = width;
            originalHeight = height;
            
            // Calculer la taille de base pour l'affichage (max 800px de large)
            const maxWidth = 800;
            canvasScale = Math.min(1, maxWidth / width);
            baseWidth = width * canvasScale;
            baseHeight = height * canvasScale;
            
            // Appliquer le zoom initial
            updateCanvasSize();
            
            canvas.addEventListener('click', handleCanvasClick);
        }

        function updateCanvasSize() {
            canvas.width = baseWidth * zoomLevel;
            canvas.height = baseHeight * zoomLevel;
            
            // Redessiner le contenu si une image est charg√©e
            if (originalImageData) {
                // Cr√©er un canvas temporaire pour redimensionner l'image
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = baseWidth;
                tempCanvas.height = baseHeight;
                
                // Dessiner l'image originale redimensionn√©e dans le canvas temporaire
                tempCtx.putImageData(originalImageData, 0, 0);
                
                // Redimensionner vers le canvas principal avec le zoom
                ctx.imageSmoothingEnabled = false; // Pour garder la nettet√©
                ctx.drawImage(tempCanvas, 0, 0, baseWidth, baseHeight, 0, 0, canvas.width, canvas.height);
                
                // Redessiner les points et fl√®ches s'ils existent
                if (startPoint) {
                    drawPoint(startPoint.x * zoomLevel, startPoint.y * zoomLevel, '#27ae60', 4);
                }
                if (endPoint) {
                    drawPoint(endPoint.x * zoomLevel, endPoint.y * zoomLevel, '#e74c3c', 4);
                    drawArrow();
                }
            }
            
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function zoomIn() {
            if (zoomLevel < 3) {
                zoomLevel += 0.25;
                updateCanvasSize();
            }
        }

        function zoomOut() {
            if (zoomLevel > 0.25) {
                zoomLevel -= 0.25;
                updateCanvasSize();
            }
        }

        function resetZoom() {
            zoomLevel = 1;
            updateCanvasSize();
        }

        function showInterface() {
            document.getElementById('canvasContainer').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('infoPanel').style.display = 'grid';
        }

        function handleCanvasClick(event) {
            if (!imageLoaded) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Convertir les coordonn√©es √©cran en coordonn√©es canvas de base
            const canvasX = (x / rect.width) * baseWidth;
            const canvasY = (y / rect.height) * baseHeight;

            if (!startPoint) {
                // Premier point : base de la fl√®che
                startPoint = { x: canvasX, y: canvasY };
                updateCanvasSize(); // Redessiner avec le nouveau point
                updatePointDisplay('startPoint', canvasX, canvasY);
                document.getElementById('instructions').innerHTML = 
                    'üìã <strong>Instructions:</strong> Maintenant, cliquez sur la pointe de la fl√®che';
            } else if (!endPoint) {
                // Deuxi√®me point : pointe de la fl√®che
                endPoint = { x: canvasX, y: canvasY };
                updateCanvasSize(); // Redessiner avec les deux points
                updatePointDisplay('endPoint', canvasX, canvasY);
                calculateDirection();
                document.getElementById('instructions').innerHTML = 
                    'üìã <strong>Instructions:</strong> Direction calcul√©e ! Cliquez n\'importe o√π pour mesurer une nouvelle fl√®che';
            } else {
                // R√©initialiser ET commencer une nouvelle mesure en un seul clic
                startPoint = { x: canvasX, y: canvasY };
                endPoint = null; // Important: remettre endPoint √† null
                
                // R√©initialiser l'affichage
                document.getElementById('endPoint').textContent = 'Non d√©fini';
                document.getElementById('angleDisplay').textContent = '--¬∞';
                document.getElementById('angleText').textContent = '--¬∞';
                document.getElementById('cardinalDirection').textContent = '--';
                document.getElementById('compassArrow').style.transform = 'rotate(0deg)';
                
                updateCanvasSize(); // Redessiner avec le nouveau point de d√©part
                updatePointDisplay('startPoint', canvasX, canvasY);
                document.getElementById('instructions').innerHTML = 
                    'üìã <strong>Instructions:</strong> Maintenant, cliquez sur la pointe de la fl√®che';
            }
        }

        function drawPoint(x, y, color, size) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, 2 * Math.PI);
            ctx.fill();
            
            // Contour blanc plus fin pour meilleure visibilit√©
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawArrow() {
            if (!startPoint || !endPoint) return;
            
            const startX = startPoint.x * zoomLevel;
            const startY = startPoint.y * zoomLevel;
            const endX = endPoint.x * zoomLevel;
            const endY = endPoint.y * zoomLevel;
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1; // Trait plus fin
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }

        function updatePointDisplay(elementId, x, y) {
            // Convertir les coordonn√©es de base en coordonn√©es r√©elles du document
            const realX = (x / baseWidth) * originalWidth;
            const realY = (y / baseHeight) * originalHeight;
            document.getElementById(elementId).textContent = `(${Math.round(realX)}, ${Math.round(realY)})`;
        }

        function calculateDirection() {
            if (!startPoint || !endPoint) return;

            // Calculer l'angle en radians (coordonn√©es de base)
            const deltaX = endPoint.x - startPoint.x;
            const deltaY = startPoint.y - endPoint.y; // Y invers√© car l'origine est en haut √† gauche
            
            let angleRad = Math.atan2(deltaX, deltaY);
            
            // Convertir en degr√©s (0¬∞ = Nord, sens horaire)
            let angleDeg = angleRad * (180 / Math.PI);
            
            // S'assurer que l'angle est entre 0¬∞ et 360¬∞
            if (angleDeg < 0) {
                angleDeg += 360;
            }

            // Mettre √† jour l'affichage
            updateAngleDisplay(angleDeg);
            updateCompass(angleDeg);
            updateCardinalDirection(angleDeg);
            
            // Mettre √† jour la direction du vent mesur√©e pour le calculateur
            document.getElementById('measuredWindDirection').textContent = Math.round(angleDeg) + '¬∞';
        }

        function updateAngleDisplay(angle) {
            document.getElementById('angleDisplay').textContent = `${Math.round(angle)}¬∞`;
            document.getElementById('angleText').textContent = `${Math.round(angle)}¬∞`;
        }

        function updateCompass(angle) {
            const compassArrow = document.getElementById('compassArrow');
            compassArrow.style.transform = `rotate(${angle}deg)`;
        }

        function updateCardinalDirection(angle) {
            let direction = '';
            
            if (angle >= 337.5 || angle < 22.5) {
                direction = 'Nord (N)';
            } else if (angle >= 22.5 && angle < 67.5) {
                direction = 'Nord-Est (NE)';
            } else if (angle >= 67.5 && angle < 112.5) {
                direction = 'Est (E)';
            } else if (angle >= 112.5 && angle < 157.5) {
                direction = 'Sud-Est (SE)';
            } else if (angle >= 157.5 && angle < 202.5) {
                direction = 'Sud (S)';
            } else if (angle >= 202.5 && angle < 247.5) {
                direction = 'Sud-Ouest (SO)';
            } else if (angle >= 247.5 && angle < 292.5) {
                direction = 'Ouest (O)';
            } else if (angle >= 292.5 && angle < 337.5) {
                direction = 'Nord-Ouest (NO)';
            }
            
            document.getElementById('cardinalDirection').textContent = direction;
        }

        function resetMeasurement() {
            startPoint = null;
            endPoint = null;
            
            // Redessiner le canvas
            updateCanvasSize();
            
            // R√©initialiser l'affichage
            document.getElementById('startPoint').textContent = 'Non d√©fini';
            document.getElementById('endPoint').textContent = 'Non d√©fini';
            document.getElementById('angleDisplay').textContent = '--¬∞';
            document.getElementById('angleText').textContent = '--¬∞';
            document.getElementById('cardinalDirection').textContent = '--';
            document.getElementById('compassArrow').style.transform = 'rotate(0deg)';
        }

        function calculateWindComponents() {
            const windSpeed = parseFloat(document.getElementById('windSpeed').value);
            const routeMagnetique = parseFloat(document.getElementById('routeMagnetique').value);
            const capPiste = parseFloat(document.getElementById('capPiste').value);
            
            if (isNaN(windSpeed) || isNaN(routeMagnetique) || isNaN(capPiste)) {
                alert('Veuillez entrer des valeurs valides pour tous les champs.');
                return;
            }
            
            if (windSpeed < 0 || windSpeed > 100) {
                alert('La force du vent doit √™tre entre 0 et 100 kt.');
                return;
            }
            
            if (routeMagnetique < 0 || routeMagnetique > 360 || capPiste < 0 || capPiste > 360) {
                alert('Les caps doivent √™tre entre 0 et 360¬∞.');
                return;
            }
            
            // R√©cup√©rer la direction du vent depuis la mesure des fl√®ches
            let windDirection = null;
            if (startPoint && endPoint) {
                const deltaX = endPoint.x - startPoint.x;
                const deltaY = startPoint.y - endPoint.y;
                let angleRad = Math.atan2(deltaX, deltaY);
                windDirection = angleRad * (180 / Math.PI);
                if (windDirection < 0) {
                    windDirection += 360;
                }
            } else {
                alert('Veuillez d\'abord mesurer la direction du vent en cliquant sur une fl√®che du document.');
                return;
            }
            
            // Calculer l'angle relatif entre le vent et la piste
            let relativeAnglePiste = windDirection - capPiste;
            
            // Normaliser l'angle entre -180¬∞ et +180¬∞
            while (relativeAnglePiste > 180) relativeAnglePiste -= 360;
            while (relativeAnglePiste < -180) relativeAnglePiste += 360;
            
            // Calculer les composantes pour la piste
            const relativeAnglePisteRad = relativeAnglePiste * (Math.PI / 180);
            const headwindComponent = windSpeed * Math.cos(relativeAnglePisteRad);
            const crosswindComponent = windSpeed * Math.sin(relativeAnglePisteRad);
            
            // Afficher les r√©sultats
            displayWindResults(headwindComponent, crosswindComponent, windSpeed, windDirection, capPiste, routeMagnetique);
        }
        
        function displayWindResults(headwind, crosswind, windSpeed, windDirection, capPiste, routeMagnetique) {
            // D√©terminer si c'est du vent de face ou de dos
            const isHeadwind = headwind >= 0;
            const headwindLabel = isHeadwind ? 'Vent de face' : 'Vent de dos';
            
            // Afficher les valeurs
            document.getElementById('headwindValue').textContent = Math.abs(headwind).toFixed(1) + ' kt';
            document.getElementById('headwindLabel').textContent = headwindLabel;
            document.getElementById('crosswindValue').textContent = Math.abs(crosswind).toFixed(1) + ' kt';
            document.getElementById('windStrength').textContent = windSpeed + ' kt';
            
            // Changer la couleur selon le type de vent
            const headwindElement = document.getElementById('headwindValue');
            headwindElement.style.color = isHeadwind ? '#27ae60' : '#e74c3c';
            
            // Afficher les r√©sultats
            document.getElementById('windResults').style.display = 'grid';
            document.getElementById('windDiagram').style.display = 'block';
            
            // Dessiner le diagramme vectoriel
            drawWindVectors(windSpeed, windDirection, capPiste, headwind, crosswind, routeMagnetique);
        }
        
        function drawWindVectors(windSpeed, windDirection, capPiste, headwind, crosswind, routeMagnetique) {
            const canvas = document.getElementById('windCanvas');
            const ctx = canvas.getContext('2d');
            
            // Effacer le canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 3; // Facteur d'√©chelle pour la visualisation
            
            // Dessiner les axes de r√©f√©rence (piste)
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Axe de piste
            const pisteAngleRad = (capPiste - 90) * (Math.PI / 180);
            const pisteEndX = centerX + Math.cos(pisteAngleRad) * 80;
            const pisteEndY = centerY + Math.sin(pisteAngleRad) * 80;
            const pisteStartX = centerX - Math.cos(pisteAngleRad) * 80;
            const pisteStartY = centerY - Math.sin(pisteAngleRad) * 80;
            
            ctx.beginPath();
            ctx.moveTo(pisteStartX, pisteStartY);
            ctx.lineTo(pisteEndX, pisteEndY);
            ctx.stroke();
            
            // Axe de route magn√©tique
            ctx.strokeStyle = '#f39c12';
            const routeAngleRad = (routeMagnetique - 90) * (Math.PI / 180);
            const routeEndX = centerX + Math.cos(routeAngleRad) * 70;
            const routeEndY = centerY + Math.sin(routeAngleRad) * 70;
            const routeStartX = centerX - Math.cos(routeAngleRad) * 70;
            const routeStartY = centerY - Math.sin(routeAngleRad) * 70;
            
            ctx.beginPath();
            ctx.moveTo(routeStartX, routeStartY);
            ctx.lineTo(routeEndX, routeEndY);
            ctx.stroke();
            
            ctx.setLineDash([]); // Arr√™ter les pointill√©s
            
            // Dessiner le vecteur vent total (bleu)
            const windAngleRad = (windDirection - 90) * (Math.PI / 180);
            const windEndX = centerX + Math.cos(windAngleRad) * windSpeed * scale;
            const windEndY = centerY + Math.sin(windAngleRad) * windSpeed * scale;
            
            drawArrowVector(ctx, centerX, centerY, windEndX, windEndY, '#3498db', 3, 'Vent total');
            
            // Dessiner la composante de face/dos (rouge)
            const headwindEndX = centerX + Math.cos(pisteAngleRad) * headwind * scale;
            const headwindEndY = centerY + Math.sin(pisteAngleRad) * headwind * scale;
            
            drawArrowVector(ctx, centerX, centerY, headwindEndX, headwindEndY, '#e74c3c', 2, 'Vent face/dos');
            
            // Dessiner la composante de travers (vert)
            const perpAngleRad = pisteAngleRad + Math.PI / 2;
            const crosswindEndX = centerX + Math.cos(perpAngleRad) * crosswind * scale;
            const crosswindEndY = centerY + Math.sin(perpAngleRad) * crosswind * scale;
            
            drawArrowVector(ctx, centerX, centerY, crosswindEndX, crosswindEndY, '#27ae60', 2, 'Vent travers');
            
            // Ajouter les √©tiquettes
            ctx.fillStyle = '#2c3e50';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            
            // √âtiquettes
            ctx.fillText(`Piste ${Math.round(capPiste)}¬∞ | Route ${Math.round(routeMagnetique)}¬∞`, centerX, 15);
            ctx.fillText(`Vent ${Math.round(windDirection)}¬∞ / ${windSpeed}kt`, centerX, canvas.height - 5);
        }
        
        function drawArrowVector(ctx, startX, startY, endX, endY, color, lineWidth, label) {
            const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
            if (length < 5) return; // Ne pas dessiner les vecteurs tr√®s petits
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            
            // Dessiner la ligne
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Dessiner la pointe de fl√®che
            const angle = Math.atan2(endY - startY, endX - startX);
            const arrowLength = 8;
            const arrowAngle = Math.PI / 6;
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowLength * Math.cos(angle - arrowAngle),
                endY - arrowLength * Math.sin(angle - arrowAngle)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowLength * Math.cos(angle + arrowAngle),
                endY - arrowLength * Math.sin(angle + arrowAngle)
            );
            ctx.stroke();
        }
    </script>
</body>
</html>
